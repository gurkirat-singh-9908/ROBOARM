#TODO: DO SOMETHING ABOUT THE ROBOT MODEL MAYBE USE THE STL FILES INSTEAD OF MTL AND OBJ
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Robotic Arm Showcase</title>
    <style>
      body { 
        margin: 0; 
        font-family: "Times New Roman", Times, serif; 
        font-size: 11pt; 
      }
      h1 { 
        font-size: 12pt; 
      }
      canvas { 
        display: block; 
      }
    </style>
  </head>
  <body>
    <h1>Robotic Arm Showcase</h1>
    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MTLLoader -->
    <script src="https://threejs.org/examples/js/loaders/MTLLoader.js"></script>
    <!-- OBJLoader -->
    <script src="https://threejs.org/examples/js/loaders/OBJLoader.js"></script>
    <script>
      let scene, camera, renderer, armModel;
      let mouseX = 0, targetRotation = 0;

      init();
      animate();

      function init() {
        // Create scene and set background color
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xcccccc); // Light gray background

        // Set up camera
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 15); // Move camera further back for better view

        // Create renderer with clear color
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xcccccc);
        document.body.appendChild(renderer.domElement);

        // Add lights with increased intensity
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // Load MTL file first, then OBJ
        const mtlLoader = new THREE.MTLLoader();
        mtlLoader.setPath('static/');
        mtlLoader.load('Robotc_arm_final.mtl', function(materials) {
          materials.preload();
          const objLoader = new THREE.OBJLoader();
          objLoader.setMaterials(materials);
          objLoader.setPath('static/');
          objLoader.load('Robotc_arm_final.obj', function(object) {
            armModel = object;
            // Adjust scale and position if necessary
            armModel.scale.set(0.5, 0.5, 0.5);
            armModel.position.y = -2; // Lower the model if needed
            scene.add(armModel);
          },
          function (xhr) {
            console.log((xhr.loaded / xhr.total * 100) + '% loaded');
          },
          function (error) {
            console.error('Error loading the model', error);
          });
        });

        // Mouse movement listener
        document.addEventListener('mousemove', onDocumentMouseMove, false);
        // Resize listener
        window.addEventListener('resize', onWindowResize, false);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onDocumentMouseMove(event) {
        // Normalize mouse position from -1 to 1
        mouseX = (event.clientX - window.innerWidth / 2) * 0.01;
        targetRotation = mouseX;
      }

      function animate() {
        requestAnimationFrame(animate);
        // Update rotation if model is loaded
        if (armModel) {
          armModel.rotation.y += (targetRotation - armModel.rotation.y) * 0.05;
        }
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
